#!/bin/bash


[[ -r /etc/bash.bashrc ]] &&
    . /etc/bash.bashrc

[[ ${TERM} && ${TERM} == dumb ]] &&
    exit 0


declare -x EDITOR='vim' \
           BROWSER='firefox' \
           WORKON_HOME=~/.local/share/venv/
mkdir -p ${WORKON_HOME}
. $(type -p virtualenvwrapper.sh || echo /dev/null)


export PIP_RESPECT_VIRTUALENV=true
export PIP_VIRTUALENV_BASE=$WORKON_HOME
# pip bash completion start
_pip_completion()
{
    COMPREPLY=( $( COMP_WORDS="${COMP_WORDS[*]}" \
                   COMP_CWORD=$COMP_CWORD \
                   PIP_AUTO_COMPLETE=1 $1 ) )
}
complete -o default -F _pip_completion pip
# pip bash completion end


<<'COMMENT'
_tmp_SSH_AUTH_SOCK="${SSH_AUTH_SOCK}"; _tmp_SSH_AGENT_PID="${SSH_AGENT_PID}"
export SSH_AUTH_SOCK="${ELLIPSIS}"run/ssh/agent.* SSH_AGENT_PID="${SSH_AUTH_SOCK##*.}"


if ! ssh-add -l > /dev/null 2>&1; then
    rm -f "${ELLIPSIS}"run/ssh/agent.*
    unset SSH_AUTH_SOCK SSH_AGENT_PID
    export SSH_AUTH_SOCK="${_tmp_SSH_AUTH_SOCK}" SSH_AGENT_PID="${_tmp_SSH_AGENT_PID}"
    ssh-add -l > /dev/null 2>&1 ||
        eval $(ssh-agent) > /dev/null
    ln -s "${SSH_AUTH_SOCK}" "${ELLIPSIS}"run/ssh/agent.${SSH_AGENT_PID}
fi
COMMENT

if [[ ${TERM} == xterm ]] ; then
    if [[ -z ${COLORTERM} ]] ; then
        if [[ -z ${XTERM_VERSION} ]] ; then
            echo "warn: terminal wrongly calling itself 'xterm'"
        else
            case "${XTERM_VERSION}" in
            "XTerm(256)") TERM="xterm-256color" ;;
            "XTerm(88)") TERM="xterm-88color" ;;
            "XTerm") ;;
            *) echo "warn: unrecognized XTERM_VERSION: ${XTERM_VERSION}" ;;
            esac
        fi
    else
        case "${COLORTERM}" in
            gnome-terminal) TERM="gnome-256color" ;;
            *) echo "warn: unrecognized COLORTERM: ${COLORTERM}" ;;
        esac
    fi
fi

SCREEN_COLORS=$(tput colors)
if [[ -z ${SCREEN_COLORS} ]] ; then
    case "${TERM}" in
        screen-*color-bce)
            echo "warn: unknown terminal ${TERM}, falling back to 'screen-bce'"
            export TERM=screen-bce
            ;;
        *-88color)
            echo "warn: unknown terminal ${TERM}, falling back to 'xterm-88color'"
            export TERM=xterm-88color
            ;;
        *-256color)
            echo "warn: unknown terminal ${TERM}, falling back to 'xterm-256color'"
            export TERM=xterm-256color
            ;;
    esac
    SCREEN_COLORS=$(tput colors)
fi

if [[ -z "$SCREEN_COLORS" ]] ; then
    case "${TERM}" in
        gnome*|xterm*|konsole*|aterm|[Ee]term)
            echo "warn: unknown terminal ${TERM}, falling back to 'xterm'"
            export TERM=xterm
            ;;
        rxvt*)
            echo "warn: unknown terminal ${TERM}, falling back to 'rxvt'"
            export TERM=rxvt
            ;;
        screen*)
            echo "warn: unknown terminal ${TERM}, falling back to 'screen'"
            export TERM=screen
            ;;
    esac
    SCREEN_COLORS=$(tput colors)
fi


# If any regex matches, we are on a workstation
export ELLIPSIS_HOSTS+=" .sta.3vera.com"

# Make an array of the above
read -a __self -r <<<"${ELLIPSIS_HOSTS}"

# PS1 special sequences
#  0   reset/default
#  1   bold
#  5   blink
#  30  fg black
#  31  fg red
#  32  fg green
#  33  fg brown
#  34  fg blue
#  35  fg purple
#  36  fg cyan
#  37  fg gray
#  40  bg black
#  41  bg red
#  42  bg green
#  43  bg brown
#  44  bg blue
#  45  bg purple
#  46  bg cyan
#  47  bg gray
#  \u  username
#  \h  hostname
#  \$  terminal
#  \W  pwd /
#  \w  pwd ~

_esc () { printf '\[\033[0%sm\]' "$(printf ';%s' "${@}")"; }

_ps1 () { (

    _self_re () { printf '%s$^$' "$(printf '%s|' "${__self[@]}")"; }

    alias e=_esc
    su=false us=false
    q='2>/dev/null'

    [[ ${EUID} == 0 ]] && su=true
    [[ ${HOSTNAME} =~ $(_self_re) ]] && us=true

    case "${su},${us}" in
        true,true) dom_c=(1 31);;
        true,false) dom_c=(30 41);;
        false,true) dom_c=(32);;
        *) dom_c=(30 42);;
    esac

    dom="$(e ${dom_c[@]})@\h"
    $su && usr="${dom}" ||
           usr="$(e 32)\u${dom}"
    hsh="$(e 37)#$(e 0) "

    echo "$(e 0)$(e 33)\
  ┌ $(e 1 32)\$(date +%l:%M%P) ${usr} $(e 0)$(e 33)
  └ $(e 1 34)\w$(e 0)
  $(e 0)$(e 33)\$(__git_ps1 '$(e 36)(%s)$(e 0) ' ${q})${hsh}"

) }

# Bash won't get SIGWINCH if another process is in the foreground.
# Enable checkwinsize so that bash will check the terminal size when
# it regains control.
# http://cnswww.cns.cwru.edu/~chet/bash/FAQ (E11)
shopt -s checkwinsize

# Enable history appending instead of overwriting.
shopt -s histappend

# Change the window title of X terminals
case ${TERM} in
	xterm*|rxvt*|Eterm|aterm|kterm|gnome*|interix)
		PROMPT_COMMAND='echo -ne "\033]0;${USER}@${HOSTNAME%%.*}:${PWD/$HOME/~}\007"'
		;;
	screen)
		PROMPT_COMMAND='echo -ne "\033_${USER}@${HOSTNAME%%.*}:${PWD/$HOME/~}\033\\"'
		;;
esac

use_color=false

# Set colorful PS1 only on colorful terminals.
# dircolors --print-database uses its own built-in database
# instead of using /etc/DIR_COLORS.  Try to use the external file
# first to take advantage of user additions.  Use internal bash
# globbing instead of external grep binary.
safe_term=${TERM//[^[:alnum:]]/?}   # sanitize TERM
match_lhs=""
[[ -f ~/.dir_colors   ]] && match_lhs="${match_lhs}$(<~/.dir_colors)"
[[ -f /etc/DIR_COLORS ]] && match_lhs="${match_lhs}$(</etc/DIR_COLORS)"
[[ -z ${match_lhs}    ]] \
	&& type -P dircolors >/dev/null \
	&& match_lhs=$(dircolors --print-database)
[[ $'\n'${match_lhs} == *$'\n'"TERM "${safe_term}* ]] && use_color=true

if ${use_color} ; then
	# Enable colors for ls, etc.  Prefer ~/.dir_colors #64489
	if type -P dircolors >/dev/null ; then
		if [[ -f ~/.dir_colors ]] ; then
			eval $(dircolors -b ~/.dir_colors)
		elif [[ -f /etc/DIR_COLORS ]] ; then
			eval $(dircolors -b /etc/DIR_COLORS)
		fi
	fi
    PS1=$(_ps1)
	alias ls='ls --color=auto'
	alias grep='grep --colour=auto'
else
	if [[ ${EUID} == 0 ]] ; then
		# show root@ when we don't have colors
		PS1='\u@\h \W \$ '
	else
		PS1='\u@\h \w \$ '
	fi
fi



HISTCONTROL=ignoreboth:erasedups
HISTFILE=${ELLIPSIS}var/cache/bash/history
HISTFILESIZE=50000
HISTIGNORE='[bf]g:exit'
HISTSIZE=50000
HISTTIMEFORMAT='%a %b %-d %-I:%M:%S %p  # '


[[ -r ${ELLIPSIS}data/profile/etc/bash/aliases ]] &&
    . ${ELLIPSIS}data/profile/etc/bash/aliases


# vim:set syntax=sh:
